/* automatically generated by rust-bindgen */
#![feature(const_fn)]

pub const NS_STYLE_INHERIT_MASK: u32 = 16777215;
pub const NS_STYLE_HAS_TEXT_DECORATION_LINES: u32 = 16777216;
pub const NS_STYLE_HAS_PSEUDO_ELEMENT_DATA: u32 = 33554432;
pub const NS_STYLE_RELEVANT_LINK_VISITED: u32 = 67108864;
pub const NS_STYLE_IS_STYLE_IF_VISITED: u32 = 134217728;
pub const NS_STYLE_CHILD_USES_GRANDANCESTOR_STYLE: u32 = 268435456;
pub const NS_STYLE_IS_SHARED: u32 = 536870912;
pub const NS_STYLE_IS_GOING_AWAY: u32 = 1073741824;
pub const NS_STYLE_SUPPRESS_LINEBREAK: u32 = 2147483648;
pub const NS_STYLE_IN_DISPLAY_NONE_SUBTREE: u64 = 4294967296;
pub const NS_STYLE_INELIGIBLE_FOR_SHARING: u64 = 8589934592;
pub const NS_STYLE_HAS_CHILD_THAT_USES_RESET_STYLE: u64 = 17179869184;
pub const NS_STYLE_CONTEXT_TYPE_SHIFT: u32 = 35;
pub const NS_RULE_NODE_IS_ANIMATION_RULE: u32 = 16777216;
pub const NS_RULE_NODE_GC_MARK: u32 = 33554432;
pub const NS_RULE_NODE_USED_DIRECTLY: u32 = 67108864;
pub const NS_RULE_NODE_IS_IMPORTANT: u32 = 134217728;
pub const NS_RULE_NODE_LEVEL_MASK: u32 = 4026531840;
pub const NS_RULE_NODE_LEVEL_SHIFT: u32 = 28;
pub const NS_RULE_NODE_HAS_ANIMATION_DATA: u32 = 2147483648;
pub const BORDER_COLOR_FOREGROUND: u32 = 32;
pub const OUTLINE_COLOR_INITIAL: u32 = 128;
pub const BORDER_COLOR_SPECIAL: u32 = 160;
pub const BORDER_STYLE_MASK: u32 = 31;
pub const NS_SPACING_MARGIN: u32 = 0;
pub const NS_SPACING_PADDING: u32 = 1;
pub const NS_SPACING_BORDER: u32 = 2;
pub enum nsIFrame { }
pub enum nsStyleContext { }
pub enum nsTextFrame { }
pub enum imgIContainer { }
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleStructID {
    nsStyleStructID_None = -1,
    nsStyleStructID_Inherited_Start = 0,
    nsStyleStructID_DUMMY1 = -1,
    eStyleStruct_Font = 0,
    eStyleStruct_Color = 1,
    eStyleStruct_List = 2,
    eStyleStruct_Text = 3,
    eStyleStruct_Visibility = 4,
    eStyleStruct_Quotes = 5,
    eStyleStruct_UserInterface = 6,
    eStyleStruct_TableBorder = 7,
    eStyleStruct_SVG = 8,
    eStyleStruct_Variables = 9,
    nsStyleStructID_Reset_Start = 10,
    nsStyleStructID_DUMMY2 = 9,
    eStyleStruct_Background = 10,
    eStyleStruct_Position = 11,
    eStyleStruct_TextReset = 12,
    eStyleStruct_Display = 13,
    eStyleStruct_Content = 14,
    eStyleStruct_UIReset = 15,
    eStyleStruct_Table = 16,
    eStyleStruct_Margin = 17,
    eStyleStruct_Padding = 18,
    eStyleStruct_Border = 19,
    eStyleStruct_Outline = 20,
    eStyleStruct_XUL = 21,
    eStyleStruct_SVGReset = 22,
    eStyleStruct_Column = 23,
    nsStyleStructID_Length = 24,
    nsStyleStructID_Inherited_Count = 10,
    nsStyleStructID_Reset_Count = 14,
}
pub type nsStyleStructID_size_t = i32;
#[repr(C)]
pub struct nsStyleFont {
    pub mFont: nsFont,
    pub mSize: nscoord,
    pub mGenericID: uint8_t,
    pub mScriptLevel: int8_t,
    pub mMathVariant: uint8_t,
    pub mMathDisplay: uint8_t,
    pub mMinFontSizeRatio: uint8_t,
    pub mExplicitLanguage: bool,
    pub mAllowZoom: bool,
    pub mScriptUnconstrainedSize: nscoord,
    pub mScriptMinSize: nscoord,
    pub mScriptSizeMultiplier: f32,
    pub mLanguage: nsCOMPtr<nsIAtom>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleGradientStop {
    pub mLocation: nsStyleCoord,
    pub mColor: nscolor,
    pub mIsInterpolationHint: bool,
}
#[repr(C)]
pub struct nsStyleGradient {
    pub mShape: uint8_t,
    pub mSize: uint8_t,
    pub mRepeating: bool,
    pub mLegacySyntax: bool,
    pub mBgPosX: nsStyleCoord,
    pub mBgPosY: nsStyleCoord,
    pub mAngle: nsStyleCoord,
    pub mRadiusX: nsStyleCoord,
    pub mRadiusY: nsStyleCoord,
    pub mStops: nsTArray<nsStyleGradientStop>,
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleImageType {
    eStyleImageType_Null = 0,
    eStyleImageType_Image = 1,
    eStyleImageType_Gradient = 2,
    eStyleImageType_Element = 3,
}
/**
 * Represents a paintable image of one of the following types.
 * (1) A real image loaded from an external source.
 * (2) A CSS linear or radial gradient.
 * (3) An element within a document, or an <img>, <video>, or <canvas> element
 *     not in a document.
 * (*) Optionally a crop rect can be set to paint a partial (rectangular)
 * region of an image. (Currently, this feature is only supported with an
 * image of type (1)).
 */
#[repr(C)]
pub struct nsStyleImage {
    pub mSubImages: nsCOMArray<imgIContainer>,
    pub mType: nsStyleImageType,
    pub mCropRect: nsAutoPtr<nsStyleSides>,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_1 {
    pub _bindgen_data_: u64,
}
impl nsStyleStruct_h_unnamed_1 {
    pub unsafe fn mImage(&mut self) -> *mut *mut imgRequestProxy {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mGradient(&mut self) -> *mut *mut nsStyleGradient {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mElementId(&mut self) -> *mut *mut u16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
#[repr(C)]
pub struct nsStyleColor {
    pub mColor: nscolor,
}
#[repr(C)]
pub struct nsStyleImageLayers {
    pub mAttachmentCount: uint32_t,
    pub mClipCount: uint32_t,
    pub mOriginCount: uint32_t,
    pub mRepeatCount: uint32_t,
    pub mPositionCount: uint32_t,
    pub mImageCount: uint32_t,
    pub mSizeCount: uint32_t,
    pub mMaskModeCount: uint32_t,
    pub mBlendModeCount: uint32_t,
    pub mCompositeCount: uint32_t,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleStruct_h_unnamed_2 {
    shorthand = 0,
    color = 1,
    image = 2,
    repeat = 3,
    position = 4,
    clip = 5,
    origin = 6,
    size = 7,
    attachment = 8,
    maskMode = 9,
    composite = 10,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Position {
    pub mXPosition: PositionCoord,
    pub mYPosition: PositionCoord,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Size {
    pub mWidth: CalcValue,
    pub mHeight: Dimension,
    pub mWidthType: uint8_t,
    pub mHeightType: uint8_t,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum DimensionType {
    eContain = 0,
    eCover = 1,
    eAuto = 2,
    eLengthPercentage = 3,
    eDimensionType_COUNT = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Repeat {
    pub mXRepeat: uint8_t,
    pub mYRepeat: uint8_t,
}
#[repr(C)]
pub struct Layer {
    pub mImage: nsStyleImage,
    pub mSourceURI: nsCOMPtr<nsIURI>,
    pub mPosition: Position,
    pub mSize: Size,
    pub mClip: uint8_t,
    pub mOrigin: uint8_t,
    pub mAttachment: uint8_t,
    pub mBlendMode: uint8_t,
    pub mComposite: uint8_t,
    pub mMaskMode: uint8_t,
    pub mRepeat: Repeat,
}
#[repr(C)]
pub struct nsStyleBackground {
    pub mImage: nsStyleImageLayers,
    pub mBackgroundColor: nscolor,
}
#[repr(C)]
pub struct nsStyleMargin {
    pub mMargin: nsStyleSides,
    pub mHasCachedMargin: bool,
    pub mCachedMargin: nsMargin,
}
#[repr(C)]
pub struct nsStylePadding {
    pub mPadding: nsStyleSides,
    pub mHasCachedPadding: bool,
    pub mCachedPadding: nsMargin,
}
#[repr(C)]
pub struct nsBorderColors {
    pub mNext: *mut nsBorderColors,
    pub mColor: nscolor,
}
#[repr(C)]
pub struct nsCSSShadowItem {
    pub mXOffset: nscoord,
    pub mYOffset: nscoord,
    pub mRadius: nscoord,
    pub mSpread: nscoord,
    pub mColor: nscolor,
    pub mHasColor: bool,
    pub mInset: bool,
}
#[repr(C)]
pub struct nsCSSShadowArray {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mLength: uint32_t,
    pub mArray: [nsCSSShadowItem; 1usize],
}
#[repr(C)]
pub struct nsStyleBorder {
    pub mBorderColors: *mut *mut nsBorderColors,
    pub mBoxShadow: RefPtr<nsCSSShadowArray>,
    pub mBorderRadius: nsStyleCorners,
    pub mBorderImageSource: nsStyleImage,
    pub mBorderImageSlice: nsStyleSides,
    pub mBorderImageWidth: nsStyleSides,
    pub mBorderImageOutset: nsStyleSides,
    pub mBorderImageFill: uint8_t,
    pub mBorderImageRepeatH: uint8_t,
    pub mBorderImageRepeatV: uint8_t,
    pub mFloatEdge: uint8_t,
    pub mBoxDecorationBreak: uint8_t,
    pub mComputedBorder: nsMargin,
    pub mBorder: nsMargin,
    pub mBorderStyle: [uint8_t; 4usize],
    pub mBorderColor: [nscolor; 4usize],
    pub mTwipsPerPixel: nscoord,
}
#[repr(C)]
pub struct nsStyleOutline {
    pub mOutlineRadius: nsStyleCorners,
    pub mOutlineWidth: nsStyleCoord,
    pub mOutlineOffset: nscoord,
    pub mCachedOutlineWidth: nscoord,
    pub mOutlineColor: nscolor,
    pub mHasCachedOutline: bool,
    pub mOutlineStyle: uint8_t,
    pub mTwipsPerPixel: nscoord,
}
#[repr(C)]
pub struct nsStyleList {
    pub mListStylePosition: uint8_t,
    pub mListStyleType: nsString,
    pub mCounterStyle: RefPtr<CounterStyle>,
    pub mListStyleImage: RefPtr<imgRequestProxy>,
    pub mImageRegion: nsRect,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleGridLine {
    pub mHasSpan: bool,
    pub mInteger: int32_t,
    pub mLineName: nsString,
}
#[repr(C)]
pub struct nsStyleGridTemplate {
    pub mLineNameLists: nsTArray<nsTArray<nsString>>,
    pub mMinTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mMaxTrackSizingFunctions: nsTArray<nsStyleCoord>,
    pub mRepeatAutoLineNameListBefore: nsTArray<nsString>,
    pub mRepeatAutoLineNameListAfter: nsTArray<nsString>,
    pub mRepeatAutoIndex: int16_t,
    pub _bitfield_1: u8,
}
impl nsStyleGridTemplate {
    pub fn set_mIsAutoFill(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << 1u32) - 1) << 0usize);
        self._bitfield_1 |= (val as u8) << 0usize;
    }
    pub fn set_mIsSubgrid(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << 1u32) - 1) << 1usize);
        self._bitfield_1 |= (val as u8) << 1usize;
    }
    pub const fn new_bitfield_1(mIsAutoFill: bool, mIsSubgrid: bool) -> u8 {
        0 | ((mIsAutoFill as u8) << 0u32) | ((mIsSubgrid as u8) << 1u32)
    }
}
#[repr(C)]
pub struct nsStylePosition {
    pub mObjectPosition: Position,
    pub mOffset: nsStyleSides,
    pub mWidth: nsStyleCoord,
    pub mMinWidth: nsStyleCoord,
    pub mMaxWidth: nsStyleCoord,
    pub mHeight: nsStyleCoord,
    pub mMinHeight: nsStyleCoord,
    pub mMaxHeight: nsStyleCoord,
    pub mFlexBasis: nsStyleCoord,
    pub mGridAutoColumnsMin: nsStyleCoord,
    pub mGridAutoColumnsMax: nsStyleCoord,
    pub mGridAutoRowsMin: nsStyleCoord,
    pub mGridAutoRowsMax: nsStyleCoord,
    pub mGridAutoFlow: uint8_t,
    pub mBoxSizing: StyleBoxSizing,
    pub mAlignContent: uint16_t,
    pub mAlignItems: uint8_t,
    pub mAlignSelf: uint8_t,
    pub mJustifyContent: uint16_t,
    pub mJustifyItems: uint8_t,
    pub mJustifySelf: uint8_t,
    pub mFlexDirection: uint8_t,
    pub mFlexWrap: uint8_t,
    pub mObjectFit: uint8_t,
    pub mOrder: int32_t,
    pub mFlexGrow: f32,
    pub mFlexShrink: f32,
    pub mZIndex: nsStyleCoord,
    pub mGridTemplateColumns: nsStyleGridTemplate,
    pub mGridTemplateRows: nsStyleGridTemplate,
    pub mGridTemplateAreas: RefPtr<GridTemplateAreasValue>,
    pub mGridColumnStart: nsStyleGridLine,
    pub mGridColumnEnd: nsStyleGridLine,
    pub mGridRowStart: nsStyleGridLine,
    pub mGridRowEnd: nsStyleGridLine,
    pub mGridColumnGap: nscoord,
    pub mGridRowGap: nscoord,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleTextOverflowSide {
    pub mString: nsString,
    pub mType: uint8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleTextOverflow {
    pub mLeft: nsStyleTextOverflowSide,
    pub mRight: nsStyleTextOverflowSide,
    pub mLogicalDirections: bool,
}
#[repr(C)]
pub struct nsStyleTextReset {
    pub mVerticalAlign: nsStyleCoord,
    pub mTextOverflow: nsStyleTextOverflow,
    pub mTextDecorationLine: uint8_t,
    pub mUnicodeBidi: uint8_t,
    pub mTextDecorationStyle: uint8_t,
    pub mTextDecorationColor: nscolor,
}
#[repr(C)]
pub struct nsStyleText {
    pub mTextAlign: uint8_t,
    pub mTextAlignLast: uint8_t,
    pub _bitfield_1: u8,
    pub mTextTransform: uint8_t,
    pub mWhiteSpace: uint8_t,
    pub mWordBreak: uint8_t,
    pub mWordWrap: uint8_t,
    pub mHyphens: uint8_t,
    pub mRubyAlign: uint8_t,
    pub mRubyPosition: uint8_t,
    pub mTextSizeAdjust: uint8_t,
    pub mTextCombineUpright: uint8_t,
    pub mControlCharacterVisibility: uint8_t,
    pub mTextEmphasisPosition: uint8_t,
    pub mTextEmphasisStyle: uint8_t,
    pub mTabSize: int32_t,
    pub mTextEmphasisColor: nscolor,
    pub mWordSpacing: nsStyleCoord,
    pub mLetterSpacing: nsStyleCoord,
    pub mLineHeight: nsStyleCoord,
    pub mTextIndent: nsStyleCoord,
    pub mTextShadow: RefPtr<nsCSSShadowArray>,
    pub mTextEmphasisStyleString: nsString,
}
impl nsStyleText {
    pub fn set_mTextAlignTrue(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << 1u32) - 1) << 0usize);
        self._bitfield_1 |= (val as u8) << 0usize;
    }
    pub fn set_mTextAlignLastTrue(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << 1u32) - 1) << 1usize);
        self._bitfield_1 |= (val as u8) << 1usize;
    }
    pub fn set_mTextEmphasisColorForeground(&mut self, val: bool) {
        self._bitfield_1 &= !(((1 << 1u32) - 1) << 2usize);
        self._bitfield_1 |= (val as u8) << 2usize;
    }
    pub const fn new_bitfield_1(mTextAlignTrue: bool,
                                mTextAlignLastTrue: bool,
                                mTextEmphasisColorForeground: bool) -> u8 {
        0 | ((mTextAlignTrue as u8) << 0u32) |
            ((mTextAlignLastTrue as u8) << 1u32) |
            ((mTextEmphasisColorForeground as u8) << 2u32)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleImageOrientation {
    pub mOrientation: uint8_t,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum Bits { ORIENTATION_MASK = 3, FLIP_MASK = 4, FROM_IMAGE_MASK = 8, }
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum Angles { ANGLE_0 = 0, ANGLE_90 = 1, ANGLE_180 = 2, ANGLE_270 = 3, }
#[repr(C)]
pub struct nsStyleVisibility {
    pub mImageOrientation: nsStyleImageOrientation,
    pub mDirection: uint8_t,
    pub mVisible: uint8_t,
    pub mPointerEvents: uint8_t,
    pub mWritingMode: uint8_t,
    pub mTextOrientation: uint8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsTimingFunction {
    pub mType: Type,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum Type {
    Ease = 0,
    Linear = 1,
    EaseIn = 2,
    EaseOut = 3,
    EaseInOut = 4,
    StepStart = 5,
    StepEnd = 6,
    CubicBezier = 7,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum StepSyntax {
    Keyword = 0,
    FunctionalWithoutKeyword = 1,
    FunctionalWithStartKeyword = 2,
    FunctionalWithEndKeyword = 3,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum Keyword { Implicit = 0, Explicit = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_3 {
    pub _bindgen_data_: [u32; 4usize],
}
impl nsStyleStruct_h_unnamed_3 {
    pub unsafe fn mFunc(&mut self) -> *mut nsStyleStruct_h_unnamed_4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mStepSyntax(&mut self) -> *mut StepSyntax {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mSteps(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(4))
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_4 {
    pub mX1: f32,
    pub mY1: f32,
    pub mX2: f32,
    pub mY2: f32,
}
#[repr(C)]
pub struct StyleTransition {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mProperty: nsCSSProperty,
    pub mUnknownProperty: nsCOMPtr<nsIAtom>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StyleAnimation {
    pub mTimingFunction: nsTimingFunction,
    pub mDuration: f32,
    pub mDelay: f32,
    pub mName: nsString,
    pub mDirection: PlaybackDirection,
    pub mFillMode: FillMode,
    pub mPlayState: uint8_t,
    pub mIterationCount: f32,
}
#[repr(C)]
pub struct nsStyleDisplay {
    pub mBinding: RefPtr<URLValue>,
    pub mClip: nsRect,
    pub mOpacity: f32,
    pub mDisplay: uint8_t,
    pub mOriginalDisplay: uint8_t,
    pub mContain: uint8_t,
    pub mAppearance: uint8_t,
    pub mPosition: uint8_t,
    pub mFloats: uint8_t,
    pub mOriginalFloats: uint8_t,
    pub mBreakType: uint8_t,
    pub mBreakInside: uint8_t,
    pub mBreakBefore: bool,
    pub mBreakAfter: bool,
    pub mOverflowX: uint8_t,
    pub mOverflowY: uint8_t,
    pub mOverflowClipBox: uint8_t,
    pub mResize: uint8_t,
    pub mClipFlags: uint8_t,
    pub mOrient: uint8_t,
    pub mMixBlendMode: uint8_t,
    pub mIsolation: uint8_t,
    pub mTopLayer: uint8_t,
    pub mWillChangeBitField: uint8_t,
    pub mTouchAction: uint8_t,
    pub mScrollBehavior: uint8_t,
    pub mScrollSnapTypeX: uint8_t,
    pub mScrollSnapTypeY: uint8_t,
    pub mScrollSnapPointsX: nsStyleCoord,
    pub mScrollSnapPointsY: nsStyleCoord,
    pub mScrollSnapDestination: Position,
    pub mScrollSnapCoordinate: nsTArray<Position>,
    pub mBackfaceVisibility: uint8_t,
    pub mTransformStyle: uint8_t,
    pub mTransformBox: uint8_t,
    pub mSpecifiedTransform: RefPtr<nsCSSValueSharedList>,
    pub mTransformOrigin: [nsStyleCoord; 3usize],
    pub mChildPerspective: nsStyleCoord,
    pub mPerspectiveOrigin: [nsStyleCoord; 2usize],
    pub mTransitionTimingFunctionCount: uint32_t,
    pub mTransitionDurationCount: uint32_t,
    pub mTransitionDelayCount: uint32_t,
    pub mTransitionPropertyCount: uint32_t,
    pub mAnimationTimingFunctionCount: uint32_t,
    pub mAnimationDurationCount: uint32_t,
    pub mAnimationDelayCount: uint32_t,
    pub mAnimationNameCount: uint32_t,
    pub mAnimationDirectionCount: uint32_t,
    pub mAnimationFillModeCount: uint32_t,
    pub mAnimationPlayStateCount: uint32_t,
    pub mAnimationIterationCountCount: uint32_t,
}
#[repr(C)]
pub struct nsStyleTable {
    pub mLayoutStrategy: uint8_t,
    pub mSpan: int32_t,
}
#[repr(C)]
pub struct nsStyleTableBorder {
    pub mBorderSpacingCol: nscoord,
    pub mBorderSpacingRow: nscoord,
    pub mBorderCollapse: uint8_t,
    pub mCaptionSide: uint8_t,
    pub mEmptyCells: uint8_t,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleContentType {
    eStyleContentType_String = 1,
    eStyleContentType_Image = 10,
    eStyleContentType_Attr = 20,
    eStyleContentType_Counter = 30,
    eStyleContentType_Counters = 31,
    eStyleContentType_OpenQuote = 40,
    eStyleContentType_CloseQuote = 41,
    eStyleContentType_NoOpenQuote = 42,
    eStyleContentType_NoCloseQuote = 43,
    eStyleContentType_AltContent = 50,
    eStyleContentType_Uninitialized = 51,
}
#[repr(C)]
pub struct nsStyleContentData {
    pub mType: nsStyleContentType,
    pub mContent: nsStyleStruct_h_unnamed_6,
    pub mImageTracked: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_6 {
    pub _bindgen_data_: u64,
}
impl nsStyleStruct_h_unnamed_6 {
    pub unsafe fn mString(&mut self) -> *mut *mut u16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mImage(&mut self) -> *mut *mut imgRequestProxy {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mCounters(&mut self) -> *mut *mut Array {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleCounterData {
    pub mCounter: nsString,
    pub mValue: int32_t,
}
#[repr(C)]
pub struct nsStyleQuotes {
    pub mQuotesCount: uint32_t,
    pub mQuotes: *mut nsString,
}
#[repr(C)]
pub struct nsStyleContent {
    pub mMarkerOffset: nsStyleCoord,
    pub mContents: *mut nsStyleContentData,
    pub mIncrements: *mut nsStyleCounterData,
    pub mResets: *mut nsStyleCounterData,
    pub mContentCount: uint32_t,
    pub mIncrementCount: uint32_t,
    pub mResetCount: uint32_t,
}
#[repr(C)]
pub struct nsStyleUIReset {
    pub mUserSelect: uint8_t,
    pub mForceBrokenImageIcon: uint8_t,
    pub mIMEMode: uint8_t,
    pub mWindowDragging: uint8_t,
    pub mWindowShadow: uint8_t,
}
#[repr(C)]
pub struct nsCursorImage {
    pub mHaveHotspot: bool,
    pub mHotspotX: f32,
    pub mHotspotY: f32,
    pub mImage: nsCOMPtr<imgIRequest>,
}
#[repr(C)]
pub struct nsStyleUserInterface {
    pub mUserInput: uint8_t,
    pub mUserModify: uint8_t,
    pub mUserFocus: uint8_t,
    pub mCursor: uint8_t,
    pub mCursorArrayLength: uint32_t,
    pub mCursorArray: *mut nsCursorImage,
}
#[repr(C)]
pub struct nsStyleXUL {
    pub mBoxFlex: f32,
    pub mBoxOrdinal: uint32_t,
    pub mBoxAlign: uint8_t,
    pub mBoxDirection: uint8_t,
    pub mBoxOrient: uint8_t,
    pub mBoxPack: uint8_t,
    pub mStretchStack: bool,
}
#[repr(C)]
pub struct nsStyleColumn {
    pub mColumnCount: uint32_t,
    pub mColumnWidth: nsStyleCoord,
    pub mColumnGap: nsStyleCoord,
    pub mColumnRuleColor: nscolor,
    pub mColumnRuleStyle: uint8_t,
    pub mColumnFill: uint8_t,
    pub mColumnRuleColorIsForeground: bool,
    pub mColumnRuleWidth: nscoord,
    pub mTwipsPerPixel: nscoord,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleSVGPaintType {
    eStyleSVGPaintType_None = 1,
    eStyleSVGPaintType_Color = 2,
    eStyleSVGPaintType_Server = 3,
    eStyleSVGPaintType_ContextFill = 4,
    eStyleSVGPaintType_ContextStroke = 5,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum nsStyleSVGOpacitySource {
    eStyleSVGOpacitySource_Normal = 0,
    eStyleSVGOpacitySource_ContextFillOpacity = 1,
    eStyleSVGOpacitySource_ContextStrokeOpacity = 2,
}
#[repr(C)]
pub struct nsStyleSVGPaint {
    pub mPaint: nsStyleStruct_h_unnamed_7,
    pub mType: nsStyleSVGPaintType,
    pub mFallbackColor: nscolor,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_7 {
    pub _bindgen_data_: u64,
}
impl nsStyleStruct_h_unnamed_7 {
    pub unsafe fn mColor(&mut self) -> *mut nscolor {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mPaintServer(&mut self) -> *mut *mut nsIURI {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
#[repr(C)]
pub struct nsStyleSVG {
    pub mFill: nsStyleSVGPaint,
    pub mStroke: nsStyleSVGPaint,
    pub mMarkerEnd: nsCOMPtr<nsIURI>,
    pub mMarkerMid: nsCOMPtr<nsIURI>,
    pub mMarkerStart: nsCOMPtr<nsIURI>,
    pub mStrokeDasharray: *mut nsStyleCoord,
    pub mStrokeDashoffset: nsStyleCoord,
    pub mStrokeWidth: nsStyleCoord,
    pub mFillOpacity: f32,
    pub mStrokeMiterlimit: f32,
    pub mStrokeOpacity: f32,
    pub mStrokeDasharrayLength: uint32_t,
    pub mClipRule: uint8_t,
    pub mColorInterpolation: uint8_t,
    pub mColorInterpolationFilters: uint8_t,
    pub mFillRule: uint8_t,
    pub mImageRendering: uint8_t,
    pub mPaintOrder: uint8_t,
    pub mShapeRendering: uint8_t,
    pub mStrokeLinecap: uint8_t,
    pub mStrokeLinejoin: uint8_t,
    pub mTextAnchor: uint8_t,
    pub mTextRendering: uint8_t,
    pub _bitfield_1: nsStyleSVGOpacitySource,
    pub _bitfield_2: nsStyleSVGOpacitySource,
    pub _bitfield_3: u8,
}
impl nsStyleSVG {
    pub fn set_mFillOpacitySource(&mut self, val: u8) {
        self._bitfield_1 &= !(((1 << 3u32) - 1) << 0usize);
        self._bitfield_1 |= (val as nsStyleSVGOpacitySource) << 0usize;
    }
    pub const fn new_bitfield_1(mFillOpacitySource: u8)
     -> nsStyleSVGOpacitySource {
        0 | ((mFillOpacitySource as nsStyleSVGOpacitySource) << 0u32)
    }
    pub fn set_mStrokeOpacitySource(&mut self, val: u8) {
        self._bitfield_2 &= !(((1 << 3u32) - 1) << 0usize);
        self._bitfield_2 |= (val as nsStyleSVGOpacitySource) << 0usize;
    }
    pub const fn new_bitfield_2(mStrokeOpacitySource: u8)
     -> nsStyleSVGOpacitySource {
        0 | ((mStrokeOpacitySource as nsStyleSVGOpacitySource) << 0u32)
    }
    pub fn set_mStrokeDasharrayFromObject(&mut self, val: bool) {
        self._bitfield_3 &= !(((1 << 1u32) - 1) << 0usize);
        self._bitfield_3 |= (val as u8) << 0usize;
    }
    pub fn set_mStrokeDashoffsetFromObject(&mut self, val: bool) {
        self._bitfield_3 &= !(((1 << 1u32) - 1) << 1usize);
        self._bitfield_3 |= (val as u8) << 1usize;
    }
    pub fn set_mStrokeWidthFromObject(&mut self, val: bool) {
        self._bitfield_3 &= !(((1 << 1u32) - 1) << 2usize);
        self._bitfield_3 |= (val as u8) << 2usize;
    }
    pub const fn new_bitfield_3(mStrokeDasharrayFromObject: bool,
                                mStrokeDashoffsetFromObject: bool,
                                mStrokeWidthFromObject: bool) -> u8 {
        0 | ((mStrokeDasharrayFromObject as u8) << 0u32) |
            ((mStrokeDashoffsetFromObject as u8) << 1u32) |
            ((mStrokeWidthFromObject as u8) << 2u32)
    }
}
#[repr(C)]
pub struct nsStyleBasicShape {
    pub mRefCnt: nsAutoRefCnt,
    pub _mOwningThread: nsAutoOwningThread,
    pub mType: Type,
    pub mFillRule: int32_t,
    pub mCoordinates: nsTArray<nsStyleCoord>,
    pub mPosition: Position,
    pub mRadius: nsStyleCorners,
}
#[repr(i32)]
#[derive(Copy, Clone)]
pub enum Type { eInset = 0, eCircle = 1, eEllipse = 2, ePolygon = 3, }
#[repr(C)]
pub struct nsStyleClipPath {
    pub mType: int32_t,
    pub mSizingBox: uint8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_8 {
    pub _bindgen_data_: u64,
}
impl nsStyleStruct_h_unnamed_8 {
    pub unsafe fn mBasicShape(&mut self) -> *mut *mut nsStyleBasicShape {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mURL(&mut self) -> *mut *mut nsIURI {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
#[repr(C)]
pub struct nsStyleFilter {
    pub mType: int32_t,
    pub mFilterParameter: nsStyleCoord,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsStyleStruct_h_unnamed_9 {
    pub _bindgen_data_: u64,
}
impl nsStyleStruct_h_unnamed_9 {
    pub unsafe fn mURL(&mut self) -> *mut *mut nsIURI {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mDropShadow(&mut self) -> *mut *mut nsCSSShadowArray {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsTArray_CopyChooser;
#[repr(C)]
pub struct nsStyleSVGReset {
    pub mMask: nsStyleImageLayers,
    pub mClipPath: nsStyleClipPath,
    pub mFilters: nsTArray<nsStyleFilter>,
    pub mStopColor: nscolor,
    pub mFloodColor: nscolor,
    pub mLightingColor: nscolor,
    pub mStopOpacity: f32,
    pub mFloodOpacity: f32,
    pub mDominantBaseline: uint8_t,
    pub mVectorEffect: uint8_t,
    pub mMaskType: uint8_t,
}
#[repr(C)]
pub struct nsStyleVariables {
    pub mVariables: CSSVariableValues,
}
