/* automatically generated by rust-bindgen */

pub use root::*;
pub mod root {
    pub const MOZ_STRING_WITH_OBSOLETE_API: ::std::os::raw::c_uint = 1;
    /**
 * typedefs for backwards compatibility
 */
    pub type nsSubstring = nsAString_internal;
    pub type nsCSubstring = nsACString_internal;
    pub type nsAFlatString = nsString;
    pub type nsASingleFragmentString = nsSubstring;
    pub type nsAFlatCString = nsCString;
    pub type nsASingleFragmentCString = nsCSubstring;
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsReadingIterator<CharT> {
        pub mStart: *const CharT,
        pub mEnd: *const CharT,
        pub mPosition: *const CharT,
    }
    /**
 * @see nsTAString
 */
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsWritingIterator<CharT> {
        pub mStart: *mut CharT,
        pub mEnd: *mut CharT,
        pub mPosition: *mut CharT,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsStringComparator;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsDefaultStringComparator {
        pub _base: nsStringComparator,
    }
    #[repr(C)]
    pub struct nsAString_internal {
        pub mData: *mut ::std::os::raw::c_ushort,
        pub mLength: ::std::os::raw::c_uint,
        pub mFlags: u32,
    }
    #[repr(u32)]
    #[derive(Copy, Clone, Debug)]
    pub enum nsTSubstring_h_unnamed_1 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsAString_internal() {
        assert_eq!(:: std:: mem:: size_of:: < nsAString_internal > (  ) ,
                   16usize);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsCStringComparator;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsDefaultCStringComparator {
        pub _base: nsCStringComparator,
    }
    #[repr(C)]
    pub struct nsACString_internal {
        pub mData: *mut ::std::os::raw::c_char,
        pub mLength: ::std::os::raw::c_uint,
        pub mFlags: u32,
    }
    #[repr(u32)]
    #[derive(Copy, Clone, Debug)]
    pub enum nsTSubstring_h_unnamed_2 {
        F_NONE = 0,
        F_TERMINATED = 1,
        F_VOIDED = 2,
        F_SHARED = 4,
        F_OWNED = 8,
        F_FIXED = 16,
        F_LITERAL = 32,
        F_CLASS_FIXED = 65536,
    }
    #[test]
    fn bindgen_test_layout_nsACString_internal() {
        assert_eq!(:: std:: mem:: size_of:: < nsACString_internal > (  ) ,
                   16usize);
    }
    /**
 * ASCII case-insensitive comparator.  (for Unicode case-insensitive
 * comparision, see nsUnicharUtils.h)
 */
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsCaseInsensitiveCStringComparator {
        pub _base: nsCStringComparator,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsCaseInsensitiveCStringArrayComparator;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsSubstringTuple {
        pub mHead: *const nsSubstringTuple,
        pub mFragA: *const nsAString_internal,
        pub mFragB: *const nsAString_internal,
    }
    #[test]
    fn bindgen_test_layout_nsSubstringTuple() {
        assert_eq!(:: std:: mem:: size_of:: < nsSubstringTuple > (  ) ,
                   24usize);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsCSubstringTuple {
        pub mHead: *const nsCSubstringTuple,
        pub mFragA: *const nsACString_internal,
        pub mFragB: *const nsACString_internal,
    }
    #[test]
    fn bindgen_test_layout_nsCSubstringTuple() {
        assert_eq!(:: std:: mem:: size_of:: < nsCSubstringTuple > (  ) ,
                   24usize);
    }
    #[repr(C)]
    pub struct nsString {
        pub _base: nsAString_internal,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsString_Segment() {
        assert_eq!(:: std:: mem:: size_of:: < nsString_Segment > (  ) ,
                   8usize);
    }
    #[test]
    fn bindgen_test_layout_nsString() {
        assert_eq!(:: std:: mem:: size_of:: < nsString > (  ) , 16usize);
    }
    #[repr(C)]
    pub struct nsFixedString {
        pub _base: nsString,
        pub mFixedCapacity: ::std::os::raw::c_uint,
        pub mFixedBuf: *mut ::std::os::raw::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_nsFixedString() {
        assert_eq!(:: std:: mem:: size_of:: < nsFixedString > (  ) , 32usize);
    }
    #[repr(C)]
    pub struct nsAutoString {
        pub _base: nsFixedString,
        pub mStorage: [::std::os::raw::c_ushort; 64usize],
    }
    #[repr(u32)]
    #[derive(Copy, Clone, Debug)]
    pub enum nsTString_h_unnamed_3 { kDefaultStorageSize = 64, }
    #[test]
    fn bindgen_test_layout_nsAutoString() {
        assert_eq!(:: std:: mem:: size_of:: < nsAutoString > (  ) , 160usize);
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsTArrayElementTraits<> {
        pub _phantom0: ::std::marker::PhantomData<nsAutoString>,
    }
    #[repr(C)]
    pub struct nsXPIDLString {
        pub _base: nsString,
    }
    #[test]
    fn bindgen_test_layout_nsXPIDLString() {
        assert_eq!(:: std:: mem:: size_of:: < nsXPIDLString > (  ) , 16usize);
    }
    #[repr(C)]
    pub struct nsGetterCopies {
        pub mString: *mut nsAString_internal,
        pub mData: *mut ::std::os::raw::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_nsGetterCopies() {
        assert_eq!(:: std:: mem:: size_of:: < nsGetterCopies > (  ) ,
                   16usize);
    }
    #[repr(C)]
    pub struct nsAdoptingString {
        pub _base: nsXPIDLString,
    }
    #[test]
    fn bindgen_test_layout_nsAdoptingString() {
        assert_eq!(:: std:: mem:: size_of:: < nsAdoptingString > (  ) ,
                   16usize);
    }
    #[repr(C)]
    pub struct nsCString {
        pub _base: nsACString_internal,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nsCString_Segment {
        pub mBegin: u32,
        pub mLength: u32,
    }
    #[test]
    fn bindgen_test_layout_nsCString_Segment() {
        assert_eq!(:: std:: mem:: size_of:: < nsCString_Segment > (  ) ,
                   8usize);
    }
    #[test]
    fn bindgen_test_layout_nsCString() {
        assert_eq!(:: std:: mem:: size_of:: < nsCString > (  ) , 16usize);
    }
    #[repr(C)]
    pub struct nsFixedCString {
        pub _base: nsCString,
        pub mFixedCapacity: ::std::os::raw::c_uint,
        pub mFixedBuf: *mut ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_nsFixedCString() {
        assert_eq!(:: std:: mem:: size_of:: < nsFixedCString > (  ) ,
                   32usize);
    }
    #[repr(C)]
    pub struct nsAutoCString {
        pub _base: nsFixedCString,
        pub mStorage: [::std::os::raw::c_char; 64usize],
    }
    #[repr(u32)]
    #[derive(Copy, Clone, Debug)]
    pub enum nsTString_h_unnamed_4 { kDefaultStorageSize = 64, }
    #[test]
    fn bindgen_test_layout_nsAutoCString() {
        assert_eq!(:: std:: mem:: size_of:: < nsAutoCString > (  ) , 96usize);
    }
    #[repr(C)]
    pub struct nsXPIDLCString {
        pub _base: nsCString,
    }
    #[test]
    fn bindgen_test_layout_nsXPIDLCString() {
        assert_eq!(:: std:: mem:: size_of:: < nsXPIDLCString > (  ) ,
                   16usize);
    }
    #[repr(C)]
    pub struct nsCGetterCopies {
        pub mString: *mut nsACString_internal,
        pub mData: *mut ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_nsCGetterCopies() {
        assert_eq!(:: std:: mem:: size_of:: < nsCGetterCopies > (  ) ,
                   16usize);
    }
    #[repr(C)]
    pub struct nsAdoptingCString {
        pub _base: nsXPIDLCString,
    }
    #[test]
    fn bindgen_test_layout_nsAdoptingCString() {
        assert_eq!(:: std:: mem:: size_of:: < nsAdoptingCString > (  ) ,
                   16usize);
    }
    /**
 * A helper class that converts a UTF-16 string to ASCII in a lossy manner
 */
    #[repr(C)]
    pub struct NS_LossyConvertUTF16toASCII {
        pub _base: nsAutoCString,
    }
    #[test]
    fn bindgen_test_layout_NS_LossyConvertUTF16toASCII() {
        assert_eq!(:: std:: mem:: size_of:: < NS_LossyConvertUTF16toASCII > (
                   ) , 96usize);
    }
    #[repr(C)]
    pub struct NS_ConvertASCIItoUTF16 {
        pub _base: nsAutoString,
    }
    #[test]
    fn bindgen_test_layout_NS_ConvertASCIItoUTF16() {
        assert_eq!(:: std:: mem:: size_of:: < NS_ConvertASCIItoUTF16 > (  ) ,
                   160usize);
    }
    /**
 * A helper class that converts a UTF-16 string to UTF-8
 */
    #[repr(C)]
    pub struct NS_ConvertUTF16toUTF8 {
        pub _base: nsAutoCString,
    }
    #[test]
    fn bindgen_test_layout_NS_ConvertUTF16toUTF8() {
        assert_eq!(:: std:: mem:: size_of:: < NS_ConvertUTF16toUTF8 > (  ) ,
                   96usize);
    }
    #[repr(C)]
    pub struct NS_ConvertUTF8toUTF16 {
        pub _base: nsAutoString,
    }
    #[test]
    fn bindgen_test_layout_NS_ConvertUTF8toUTF16() {
        assert_eq!(:: std:: mem:: size_of:: < NS_ConvertUTF8toUTF16 > (  ) ,
                   160usize);
    }
    pub type nsVoidableString = nsAutoString;
}
